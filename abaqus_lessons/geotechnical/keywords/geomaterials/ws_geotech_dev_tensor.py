"""
Module that provides a functions to compute the deviatoric and volumetric quantities.
"""

from odbAccess import *
from abaqusConstants import *
import sys
from types import *
from abaqus import session

tensorTypes = [TENSOR_3D_FULL, TENSOR_3D_PLANAR, TENSOR_3D_SURFACE, TENSOR_2D_PLANAR, TENSOR_2D_SURFACE]
ndis = [3,3,2,3,2]
engineeringQuantities = ['E','LE', 'PE']

def computeDevComponents(odb,variable):
    """
    """
    if type(odb) != OdbType:
        raise TypeError,'odb should be of type OdbType; found %s' % type(odb)
    if type(variable) != StringType:
        raise TypeError,'variable should be of type String; found %s' % type(variable)

    if odb.isReadOnly:
        errMsg = 'The output database has been opened as read only. Please check for .lck file or the file permissions.'
        raise ValueError, errMsg

    # find if this ODB is from a standard or explicit analysis
    worryAbtIsEng = True
    analysisCode = odb.jobData.analysisCode
    warningString = ''
    if analysisCode == ABAQUS_STANDARD:
        worryAbtIsEng = True
    elif analysisCode == ABAQUS_EXPLICIT:
        worryAbtIsEng = False
    else:
        # ODB Generated by other means eg: using ODB_API.
        # will use tensorial approach
        #
        worryAbtIsEng = False
        warningString += 'The output database is not generated using ABAQUS/Standard or ABAQUS/Explicit.\n'
        warningString += 'The tensor will be treated as having tensorial shear components.\n'
        
    # Now loop through the steps and compute the fieldoutputs
    #
    
    for step in odb.steps.values():
        print 'Processing step: "%s"...' % step.name
        frameIndex = 0
        for frame in step.frames:
            print '\tProcessing frame: %d...' % frameIndex
            frameIndex += 1
            if not frame.fieldOutputs.has_key(variable):
                print '\t\tThere is no %s fieldoutput in this frame. Skipping the frame.'%variable
                continue
            fo = frame.fieldOutputs[variable]
            if fo.type not in tensorTypes:
                raise ValueError, 'The specified variable is not a valid tensor quantity.\nThe deviatoric and volumetric components can be computed only for the tensor quantities.'

            # Get the ndi, ntens, and multiplication factor for this fieldOutput
            #
            componentLabels = fo.componentLabels            
            ntens = len(componentLabels)
            ndi = ndis[tensorTypes.index(fo.type)]

            if worryAbtIsEng:
                if variable in engineeringQuantities:
                    factor = 0.5
                else:
                    factor = 2.0
            else:
                factor = 2.0
                if warningString:
                    print warningString
                   

            # Create new fieldOutputs
            #
            uvarm1 = frame.FieldOutput(name = 'VOL_%s' % variable, description='Volumetric', type=SCALAR)
            uvarm2 = frame.FieldOutput(name = 'EQ_DEV_%s' % variable, description='Deviotoric', type=SCALAR)            

            ndiScalars = [] # store the fields so that there is no need to compute the scalars again

            # Compute UVARM1
            #
            epvol = 0.0
            for i in range(ndi):
                temp = fo.getScalarField(componentLabel = componentLabels[i])
                ndiScalars.append(temp)
                epvol += temp
                
            uvarm1.addData(field=epvol)
            
            # Now compute the uvarm2
            #
            nshearScalars = []

            for i in range(ndi,ntens):
                nshearScalars.append(fo.getScalarField(componentLabel=componentLabels[i]))

            wt = ndiScalars + nshearScalars
            epvolby3 = epvol*(1.0/3)
            epdev = 0.0
            for i in range(ndi):
                wt[i] = wt[i] - epvolby3
                epdev = epdev + (wt[i]*wt[i])

            for i in range(ndi,ntens):                
                epdev = epdev + (factor*wt[i]*wt[i])

            twoby3 = 2.0/3
            
            temp = sqrt(twoby3*epdev)
            uvarm2.addData(field=temp)
            
    odb.save()    
    print 'Successfully completed computing the uvarms.'

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def getInputsAndComputeUvarm():
    """
    """
    vp = session.viewports[session.currentViewportName]
    odbDisplay = vp.odbDisplay

    # Check if the viewport is associated with an ODB
    #
    if not odbDisplay.name:
        raise ValueError, 'There is no output database (ODB) \nassociated with the current viewport.\n\nSelect an ODB from the context bar,\nor use "File->Open" to open an ODB.'

    odbName = odbDisplay.name
    odb = session.odbs[odbName]

    if odb.isReadOnly:
        errMsg = 'The output database has been opened as read only. Please check for .lck file or the file permissions.'
        raise ValueError, errMsg

    # Now get the variable name
    #
    variable = getInput('Enter tensor output variable name:','S')
    if variable == None:
        print 'Cancelling...'
        return
    elif not variable:
        raise ValueError, 'Variable name cannot be empty.'

    # Now call the compute function
    #
    computeDevComponents(odb,variable)

    # Close and open the ODB to refresh the fieldoutput values
    #

    odbName = odb.name
    odb.close()
    odb = session.openOdb(odbName, readOnly=False)
    vp.setValues(displayedObject=odb)
    

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

if __name__ == '__main__':
    getInputsAndComputeUvarm()

    
    

    
    
            
                
            
                                           

            
            
            
                

        
